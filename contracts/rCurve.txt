// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.6.0;

import '../Interfaces/CurveInterface.sol';
import '../Interfaces/ERC20Interface.sol';

contract rCurve {

    uint128 constant N_COINS = 3;
    address owner;
    
    Erc20[N_COINS] tokens;
    Erc20 PoolToken;
    curvePool public Pool = curvePool(0x5B2A3246d70ABB9121EA532a9Ac6f77D45366643); // This address is on ropsten

    address LPaddr;

    uint256[N_COINS] poolBalance;

    constructor(
        Erc20 _poolToken,
        Erc20[N_COINS] memory _tokens,
        address addr
    ) public {
        owner = msg.sender;

        PoolToken = _poolToken;

        for(uint8 i=0; i<N_COINS; i++) {
            tokens[i] = _tokens[i];
        }

        LPaddr = addr;
    }

    //set pool
    function setPool(curvePool _pool) public {
        require(msg.sender == owner);
        Pool = _pool;
    }

    // Deposit
    function _deposit(uint256[N_COINS] memory amounts) internal {
        for(uint8 i=0; i<N_COINS; i++){
            if(amounts[i] > 0){
               tokens[i].approve(address(Pool), amounts[i]);
            }
        }

        uint mintAmount = Pool.calc_token_amount(amounts, true);
        mintAmount = (99 * mintAmount) / 100;
        Pool.add_liquidity(amounts, mintAmount);

        for(uint8 i=0; i<N_COINS; i++){
            poolBalance[i] += amounts[i];
        }
    }

    // Withdraw
    function _withdraw(uint256[N_COINS] memory amounts) internal {
        uint256 max_burn = 0;
        uint256 decimal = 0;
        uint256 temp = 0;

        for(uint8 i=0; i<N_COINS; i++) {
            decimal = tokens[i].decimals();
            temp = amounts[i] / 10**decimal;
            max_burn = max_burn + temp;
        }

        max_burn = max_burn + (max_burn * 2) / 100;
        decimal = PoolToken.decimals();
        max_burn = max_burn * 10**decimal;

        Pool.remove_liquidity_imbalance(amounts, max_burn);

        for(uint8 i=0; i<N_COINS; i++){
            poolBalance[i] -= amounts[i];
        }
    }

    /* Functions for royaleLP */
    function deposit(uint256[N_COINS] calldata amount) external {
        require(msg.sender == LPaddr, "not authorized");
        _deposit(amount);
    }

    function withdraw(uint256[N_COINS] calldata amount) external {
        require(msg.sender == LPaddr, "not authorized");
        _withdraw(amount);

        for(uint8 i=0; i<N_COINS; i++) {
            if(amount[i] > 0) {
                tokens[i].transfer(LPaddr, amount[i]);
            }
        }
    }

    function _withdrawAll() internal {
        uint crvBal = PoolToken.balanceOf(address(this));
        Pool.remove_liquidity(crvBal, [poolBalance[0], poolBalance[1], poolBalance[2]]);
    }

    function changePool(address _to) external {
        require(msg.sender == owner, "not authorized");

        _withdrawAll();

        for(uint8 i=0; i<3; i++) {
            uint amt = tokens[i].balanceOf(address(this));
            if(amt > 0) {
                tokens[i].transfer(_to, amt);
            }
        }
    }
}